# Lifetimes

lifetimes ensure that references are valid as long as we need them to be.

every reference in Rust has a lifetime, which is the scope for which that reference is valid.

The main aim of lifetimes is to prevent [dangling references](reference-borrowing#dangling-references)

## Lifetime Annotation Syntax

Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.

```rust title= showLineNumbers
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

### Lifetime Annotations in Function Signatures

We want the signature to express the following constraint: the returned reference will be valid as long as both the parameters are valid.

```rust title= showLineNumbers
// highlight-next-line
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

<Admonition type="info" title="info">

The `longest` function definition specifying that all the references in the signature must have the same lifetime `'a`

</Admonition>

The generic lifetime `'a` will get the concrete lifetime that is equal to the <Color color="var(--secondary-font-color)"> smaller </Color> of the lifetimes of `x` and `y`.

Because we’ve annotated the returned reference with the same lifetime parameter `'a`, the returned reference will also be valid for the length of the smaller of the lifetimes of `x` and `y`

```rust title= showLineNumbers
fn main() {
    let string1 = String::from("long string is long");
    let result;
    // highlight-start
    // lifetime of string2
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    // highlight-end
    // highlight-error-next-line
    println!("The longest string is {}", result); // `string2` does not live long enough
}
```

---

Because we can not return a reference of a value created within function (dangling reference), typically a lifetime of returned type would be the same as a lifetime of the function parameters.

```rust title= showLineNumbers
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    // highlight-error-next-line
    result.as_str() // cannot return reference to local variable `result`
}
```

## Lifetime in Struct

If we define `struct` that hold reference, we need to add lifetime on every reference

```rust title= showLineNumbers
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

This annotation means an instance of `ImportantExcerpt` can’t outlive the reference it holds in its `part` field. <Color color="var(--writer-additional-note-font-color)"> //\\\ </Color> fields lifetime
need to be bigger(live longer) than instance lifetime.

These rules apply to `fn` definitions as well as `impl` blocks.

## Lifetime Elision

In some cases, Rust can infer lifetime without you explicitly specific them.

They’re a set of particular cases that the compiler will consider, if your code fits these cases, you don’t need to write the lifetimes explicitly.

Lifetimes on function or method parameters are called <Color color="var(--secondary-font-color)"> input lifetimes </Color>

Lifetimes on return values are called <Color color="var(--secondary-font-color)"> output lifetimes </Color>.

### Rules

The compiler uses three rules to figure out the lifetimes of the references when there aren’t explicit annotations.

If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error.

1. The first rule is that the compiler assigns a lifetime parameter to each parameter that’s a reference.
   - from `fn foo(x: &i32, y: &i32);` to `fn foo<'a, 'b>(x: &'a i32, y: &'b i32);`
1. The second rule is that, if there is <Color color="var(--secondary-font-color)"> exactly one input lifetime </Color> parameter, that lifetime is assigned to all <Color color="var(--secondary-font-color)"> output lifetime </Color> parameters
   - `fn foo<'a>(x: &'a i32) -> &'a i32`.
1. The third rule is that, if there are <Color color="var(--secondary-font-color)"> multiple input lifetime </Color> parameters, but one of them is `&self` or `&mut self`, the lifetime of `self` is assigned to all <Color color="var(--secondary-font-color)"> output lifetime </Color> parameters.

### Lifetime in method definitions

Lifetime names for struct fields always need to be <Color color="var(--secondary-font-color)"> declared </Color> after the `impl` keyword
and then <Color color="var(--secondary-font-color)"> used </Color> after the struct's name, because those lifetimes are part of the struct's type.

<Admonition type="caution" title="????" icon="">

In method signatures inside the impl block, references might be tied to the lifetime of references in the struct’s fields, or they might be independent.

</Admonition>

```rust title= showLineNumbers
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

The lifetime parameter declaration after `impl` and its use after the type name are required

But we’re not required to annotate the lifetime of the reference to self because of the first elision rule.

Here is an example where the third lifetime elision rule applies:

```rust title= showLineNumbers
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }

    // after apply elision rules
    fn announce_and_return_part<'a, 'b>(&'a self, announcement: &'b str) -> &'a str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```

There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both `&self` and `announcement` their own lifetimes.

Then, because one of the parameters is `&self`, the return type gets the lifetime of `&self`.

## Static lifetime

Using `'static` lifetime annotation infer that reference can live for the entire duration of the program.

```rust title= showLineNumbers
let s: &'static str = "I have a static lifetime.";
```

<Admonition type="info" title="info">

All string literals have the `'static` lifetime.<Color color="var(--not-require-but-good-to-know-font-color)"> The text of this string is stored directly in the program’s binary, which is always available. Therefore, the lifetime of all string literals is `'static`</Color>

</Admonition>

## <Color color="var(--not-require-but-good-to-know-font-color)"> Example of using generic, trait bounds and lifetime together </Color>

```rust title= showLineNumbers
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## Miscellaneous

Rust have no null value and defining variable without initial value is valid

```rust title= showLineNumbers
let foo: u8;
```

`foo` here dont have value but if you try to use `foo` while it have no value, you will get compile-time error

```rust title= showLineNumbers
let foo: u8;
// highlight-error-next-line
println!("{foo}"); // used binding `foo` isn't initialized
```

---

If <Color color="var(--secondary-font-color)"> immutable </Color> variable have no initial value, only the first assignment is valid

```rust title= showLineNumbers
let foo: u8;
foo = 10;
// highlight-error-next-line
foo = 20; // cannot assign twice to immutable variable `foo`
println!("{foo}");
```

---

convert `String` to `&str` using

```rust title= showLineNumbers
 let foo = String::from("foo");
 foo.as_str();
```

<br />

---

# Sources

- https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
