# Vectors

`Vec<T>`, also known as a vector.

Vectors allow you to store more than one value in a single data structure that <Color color="var(--secondary-font-color)"> puts all the values next to each other in memory </Color>.

Vectors can only store values of the <Color color="var(--secondary-font-color)"> same type </Color>.

## Creating a Vector

```rust title= showLineNumbers
let v: Vec<i32> = Vec::new();
```

<Admonition type="note" title="note">

We added a type annotation here. Because we arenâ€™t inserting any values into this vector

</Admonition>

Rust provides the `vec!` macro, which will create a new vector that holds the values you give it.

```rust title= showLineNumbers
let v = vec![1, 2, 3];
```

## Updating a Vector

```rust title= showLineNumbers
// highlight-next-line
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

<Admonition type="note" title="note">

Changing Vector value require Vector to be mutable.

</Admonition>

## Reading elements of Vector

### By index syntax

```rust title= showLineNumbers
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2]; // note that ownership concept still apply
println!("The third element is {third}");
```

### By `vector.get` method

`get` accept index as an argument and return `Option<&T>`

```rust title= showLineNumbers
let v = vec![1, 2, 3, 4, 5];

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

### When reading out of range index

- index syntax will cause the program to panic
- `get` method will return `None` variant

<Admonition type="tip" title="tip">

Use index syntax when you want program to crash when there s an attempt to access invalid index

</Admonition>

## Reference Scope

mutable and immutable references in the same scope concept still apply

```rust title= showLineNumbers
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

// highlight-error-next-line
v.push(6); // cannot borrow `v` as mutable because it is also borrowed as immutable

println!("The first element is: {first}");
```

<Admonition type="info" title="info">

Why should a reference to the first element care about changes at the end of the vector?

Because vectors put the values next to each other in memory.

Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space.

Reference might still point to the old stale memory location

</Admonition>

## Iterating

```rust title= showLineNumbers
// with immutable ref
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}

// with mutable ref
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

<Admonition type="note" title="note">

If we attempted to insert or remove items in the for loop bodies, we would get a compiler error.

The reference to the vector that the for loop holds <Color color="var(--secondary-font-color)"> prevents simultaneous modification </Color> <Color color="var(--primary-font-color)"> of the whole vector </Color>.

</Admonition>

<Admonition type="info" title="info">

Iterate vector without using reference is valid. But all items can not no longer be used because they are moved.

```rust title= showLineNumbers
let v = vec![100, 32, 57];
for i in v {
    // move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
    // - `v` moved due to this implicit call to `.into_iter()`
    println!("{i}");
}

// highlight-error-next-line
println("{}", v[0]); // borrow of moved value: `v`
```

</Admonition>

## Using Enum to Store Multiple Type

When we need <Color color="var(--secondary-font-color)"> one type to represent elements of different types </Color>, we can define and use an enum

Because enum variants are consider the same enum type, we can create a vector to hold that enum and so, ultimately, holds different types.

```rust title= showLineNumbers
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

## Dropping a Vector Drops Its Elements

When the vector gets dropped, all of its contents are also dropped.

```rust title= showLineNumbers
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
```

<Admonition type="tip" title="later" icon="">

[Vector API](https://doc.rust-lang.org/std/vec/struct.Vec.html)

</Admonition>

<br />

---

# Sources

- https://doc.rust-lang.org/book/ch08-01-vectors.html
