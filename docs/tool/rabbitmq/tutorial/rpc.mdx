---
sidebar_position: 7000
tags:
  - rabbitmq
---

# Remote procedure call (RPC)

In the [second tutorial](work-queue) we learned how to use Work Queues to distribute time-consuming tasks among multiple workers.

But what if we need to run a function <Color color="var(--secondary-font-color)"> on a </Color> <Color color="var(--primary-font-color)"> remote </Color> <Color color="var(--secondary-font-color)"> computer </Color> and <Color color="var(--secondary-font-color)"> wait for the result </Color>?
Well, that's a different story. This pattern is commonly known as Remote Procedure Call or RPC.

In this tutorial we're going to use RabbitMQ to build an RPC system: a client and a scalable RPC server.

As we don't have any time-consuming tasks that are worth distributing, we're going to create a dummy RPC service that returns Fibonacci numbers.

<Admonition type="tip" title="later">

Although RPC is a pretty common pattern in computing, it's often criticised.

The problems arise when a programmer is not aware whether a function call is local or if it's a slow RPC.

Confusions like that result in an unpredictable system and adds unnecessary complexity to debugging.

Instead of simplifying software, misused RPC can result in unmaintainable spaghetti code.

Bearing that in mind, consider the following advice:

- Make sure it's obvious which function call is local and which is remote.
- Document your system. Make the dependencies between components clear.
- Handle error cases. How should the client react when the RPC server is down for a long time?

When in doubt avoid RPC. If you can, you should use an asynchronous pipeline - instead of RPC-like blocking, results are asynchronously pushed to a next computation stage

</Admonition>

## Callback queue

In general doing RPC over RabbitMQ is easy. A client sends a request message and a server replies with a response message.

In order to receive a response we need to send a `callback queue`'s address with the request.

When server completed the task , it will publish the response message to this callback queue.

We can use the default exchange. Let's try it:

```javascript title= showLineNumbers
channel.assertQueue("", {
  exclusive: true,
});

channel.sendToQueue("rpc_queue", Buffer.from("10"), {
  replyTo: queue_name,
});

// ... then code to read a response message from the callback queue ...
```

<Admonition type="tip" title="later">

Message properties

The <Color color="var(--secondary-font-color)"> AMQP 0-9-1 protocol </Color> predefines a set of 14 properties that go with a message. Most of the properties are rarely used, with the exception of the following:

- `persistent`: Marks a message as persistent (with a value of true) or transient (false).
- `content_type`: Used to describe the mime-type of the encoding.
  - For example for the often used JSON encoding it is a good practice to set this property to: `application/json`.
- `reply_to`: Commonly used to name a callback queue.
- `correlation_id`: Identify which response belongs to which request.

</Admonition>

## Correlation Id

In the method presented above we suggest creating a callback queue for every RPC request.

That's pretty inefficient, we can create a single callback queue per client.

A single callback queue come with the issue that the queue is not clear which request the response belongs to.

That's when the `correlation_id` property is used.

We're going to set it to a unique value for every request. Later,
when we consume a message from the callback queue we'll look at this property,
and based on that we'll be able to <Color color="var(--secondary-font-color)"> match a response with a request </Color>.

<Admonition type="info" title="info">

If we see an `unknown` `correlation_id` value, we may safely discard the message - it doesn't belong to our requests.

<details>

<summary> Why ignore unknown messages rather than raise error? </summary>

It's due to a possibility of a race condition on the server side.

Although unlikely, it is possible that the RPC server will die just after sending us the answer, but before sending an acknowledgment message for the request.

If that happens, the restarted RPC server will process the request again.

That's why on the client we must handle the duplicate responses gracefully, and the RPC should ideally be idempotent.

</details>

</Admonition>

## Summary

![rpc flow](../assets/rpc-flow.png)

- When the Client starts up, it creates an anonymous exclusive callback queue `amq.gen-Xa2...`.
- For an RPC request, the Client sends a message with two properties:
  - `reply_to`, which is set to the callback queue
  - `correlation_id`, which is set to a unique value for every request.
- The request is sent to an `rpc_queue` queue.
- The RPC worker (aka: server) is waiting for requests on that queue. When a request appears, it does the job and sends a message with the result back to the Client, using the queue from the `reply_to` field.
- The client <Color color="var(--secondary-font-color)"> waits for data on the callback queue </Color>. When a message appears, it checks the `correlation_id` property. If it matches the <Color color="var(--secondary-font-color)"> value from the </Color> <Color color="var(--primary-font-color)"> request </Color> it returns the response to the application.

## Code example

The code for our RPC server `rpc_server.js` looks like this:

```javascript title=rpc_server.js showLineNumbers
var amqp = require("amqplib/callback_api");

amqp.connect("amqp://localhost", function (error0, connection) {
  if (error0) {
    throw error0;
  }
  connection.createChannel(function (error1, channel) {
    if (error1) {
      throw error1;
    }
    var queue = "rpc_queue";

    channel.assertQueue(queue, {
      durable: false,
    });
    channel.prefetch(1);
    console.log(" [x] Awaiting RPC requests");
    channel.consume(queue, function reply(msg) {
      var n = parseInt(msg.content.toString());

      console.log(" [.] fib(%d)", n);

      var r = fibonacci(n);

      // highlight-start
      channel.sendToQueue(msg.properties.replyTo, Buffer.from(r.toString()), {
        correlationId: msg.properties.correlationId,
      });

      channel.ack(msg);
      // highlight-end
    });
  });
});

function fibonacci(n) {
  if (n == 0 || n == 1) return n;
  else return fibonacci(n - 1) + fibonacci(n - 2);
}
```

The server code is rather straightforward:

- As usual we start by establishing the connection, channel and declaring the queue.
- We might want to run more than one server process. In order to spread the load equally over multiple servers we need to set the prefetch setting on channel.
- We use `Channel.consume` to consume messages from the queue. Then we do the work and send the response back.

The code for our RPC client `rpc_client.js`:

```javascript title=rpc_client.js showLineNumbers
var amqp = require("amqplib/callback_api");

var args = process.argv.slice(2);

if (args.length == 0) {
  console.log("Usage: rpc_client.js num");
  process.exit(1);
}

amqp.connect("amqp://localhost", function (error0, connection) {
  if (error0) {
    throw error0;
  }
  connection.createChannel(function (error1, channel) {
    if (error1) {
      throw error1;
    }
    channel.assertQueue(
      "",
      {
        exclusive: true,
      },
      function (error2, q) {
        if (error2) {
          throw error2;
        }
        var correlationId = generateUuid();
        var num = parseInt(args[0]);

        console.log(" [x] Requesting fib(%d)", num);

        // highlight-start
        // consuming response from temporary/exclusice queue
        channel.consume(
          q.queue,
          function (msg) {
            if (msg.properties.correlationId == correlationId) {
              console.log(" [.] Got %s", msg.content.toString());
              setTimeout(function () {
                connection.close();
                process.exit(0);
              }, 500);
            }
          },
          {
            noAck: true,
          }
        );
        // highlight-end

        // highlight-start
        // publish message to rpc server
        channel.sendToQueue("rpc_queue", Buffer.from(num.toString()), {
          correlationId: correlationId,
          replyTo: q.queue,
        });
        // highlight-end
      }
    );
  });
});

function generateUuid() {
  return (
    Math.random().toString() +
    Math.random().toString() +
    Math.random().toString()
  );
}
```

### Running the example code

We can start the server:

```bash title=
node rpc_server.js
```

Client publish message to get a fibonacci number:

```bash title=
node rpc_client.js 30
```

<Admonition type="info" title="info">

The design presented here is not the only possible implementation of a RPC service, but it has some important advantages:

- If the RPC server is too slow, you can scale up by just running another one. Try running a second `rpc_server.js` in a new console.
- On the client side, the RPC requires sending and receiving only one message. As a result the RPC client needs only one network round trip for a single RPC request.

</Admonition>

<Admonition type="note" title="note">

Our code is still pretty simplistic and doesn't try to solve more complex (but important) problems, like:

- How should the client react if there are no servers running?
- Should a client have some kind of timeout for the RPC?
- If the server malfunctions and raises an exception, should it be forwarded to the client?
- Protecting against invalid incoming messages (eg checking bounds, type) before processing.

</Admonition>

<br />

---

# Sources

- https://www.rabbitmq.com/tutorials/tutorial-six-javascript.html
